{
  "name": "continuation",
  "version": "0.1.7",
  "description": "Continuation.js is a compiler for asynchronous JavaScript Continuation-Passing style transformation",
  "author": {
    "name": "BYVoid"
  },
  "license": "BSD",
  "main": "continuation.js",
  "bin": {
    "continuation": "./bin/continuation"
  },
  "directories": {
    "lib": "lib",
    "bin": "bin",
    "test": "test"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/BYVoid/continuation.git"
  },
  "preferGlobal": true,
  "bugs": {
    "url": "https://github.com/BYVoid/continuation/issues"
  },
  "keywords": [
    "compiler",
    "continuation",
    "async",
    "cps",
    "monad",
    "coffeescript",
    "livescript"
  ],
  "dependencies": {
    "esprima": "1.2.5",
    "escodegen": "1.6.1",
    "commander": "2.6.0",
    "mkdirp": "0.5.0"
  },
  "devDependencies": {
    "mocha": "2.1.0"
  },
  "readme": "# Continuation.js\n\n## Installation\n\nInstall Continuation.js with [npm](https://npmjs.org/package/continuation):\n\n    npm install -g continuation\n\nLatest version: 0.1.7 (2015-04-08)\n\n[Change log](https://github.com/BYVoid/continuation/blob/master/CHANGELOG.md)\n\nNode.js\u001c version required: >= 0.8\n\n[![Build Status](https://travis-ci.org/BYVoid/continuation.png?branch=master)](https://travis-ci.org/BYVoid/continuation)\n\n## Overview\n\nContinuation.js is a compiler for [Continuation-Passing Style](http://en.wikipedia.org/wiki/Continuation-passing_style) transformation, which simplifies asynchronous JavaScript programming.\nIt translates slightly flavored JavaScript syntax into standard JavaScript, so it can be also called a \"translator\".\nContinuation.js introduces a virtual function ``cont``, which allow you to write continuation-passing style code (or asynchronous callback style code) far easier.\n`cont` is not a actual function, but a mark with the same syntax to function calls in JavaScript.\nBy using Continuation.js you can write asynchronous control flows like flat threaded code, and it compiles it into continuation-passing style code.\n\nTypically, writing with asynchronous control flow is a pain, because you will easily write nested callbacks like below:\n\n```javascript\nfunction textProcessing(callback) {\n  fs.readFile('somefile.txt', 'utf-8', function (err, contents) {\n    if (err) return callback(err);\n    //process contents\n    contents = contents.toUpperCase();\n    fs.readFile('somefile2.txt', 'utf-8', function (err, contents2) {\n      if (err) return callback(err);\n      contents += contents2;\n      fs.writeFile('somefile_concat_uppercase.txt', contents, function (err) {\n        if (err) return callback(err);\n        callback(null, contents);\n      });\n    });\n  });\n}\ntextProcessing(function (err, contents) {\n  if (err)\n    console.error(err);\n});\n```\n\nThis kind of coding style is called \"callback hells\" or \"callback pyramids\".\nWhile using Continuation.js, you directly write:\n\n```javascript\nfunction textProcessing(ret) {\n  fs.readFile('somefile.txt', 'utf-8', cont(err, contents));\n  if (err) return ret(err);\n  contents = contents.toUpperCase();\n  fs.readFile('somefile2.txt', 'utf-8', cont(err, contents2));\n  if (err) return ret(err);\n  contents += contents2;\n  fs.writeFile('somefile_concat_uppercase.txt', contents, cont(err));\n  if (err) return ret(err);\n  ret(null, contents);\n}\ntextProcessing(cont(err, contents));\nif (err)\n  console.error(err);\n```\n\nThe code above is flatted by using the virtual function ``cont``.\nControl flow must \"wait\" for the return of asynchronous function call ``fs.readFile``.\nParameters in the argument list of ``cont`` will be set after it returns.\n\"Return\" here is a little confusing because in an asynchronous function \"return\" means callback function called, not \"return\" in the literal sense.\nAn asynchronous function usually returns immediately (by encountering ``return`` statement or the end of the function scope) while the callback function could be called later.\nYou can be understood as all the statements after ``cont`` until the end of the function are the callback function of the asynchronous function call.\nThe code feels like threaded code, but it is still asynchronous while executing.\n\nEven more simply, the asynchronous error can be held with JavaScript ``try...catch`` syntax and another virtual function call ``obtain`` provided by Continuation.js.\n``obtain(a)`` is equivalent to ``cont(err, a)``, and ``err`` would be thrown if it is not ``undefined``.\n\n```javascript\nfunction textProcessing(ret) {\n  try {\n    fs.readFile('somefile.txt', 'utf-8', obtain(contents));\n    contents = contents.toUpperCase();\n    fs.readFile('somefile2.txt', 'utf-8', obtain(contents2));\n    contents += contents2;\n    fs.writeFile('somefile_concat_uppercase.txt', contents, obtain());\n    ret(null, contents);\n  } catch(err) {\n    ret(err);\n  }\n}\ntry {\n  textProcessing(obtain(contents));\n} catch(err) {\n  console.error(err);\n}\n```\n\n## Features\n\n* A JIT (Just-in-time compilation) and AOT (Ahead-of-time) compiler\n* Strictly no runtime dependence\n* No additional non-native JavaScript syntax and very few reserved keywords (only ``cont``, ``obtain`` and ``parallel``)\n* Flexible coding style and readable compiled code\n* Compatible with [CoffeeScript](http://coffeescript.org/) and [LiveScript](http://livescript.net/) (and other compile-to-js language)\n* Supports both Node.js and browser-side JavaScript\n* Supports execution in parallel and lightweight thread\n\n## Documentation\n\n### cont\n\n``cont`` is a mark of asynchronous calls.\nIt must be used in the place of callback function parameter of a function call.\nThe parameters in ``cont`` will be set to the values of arguments of the callback function.\nIf parameter of ``cont`` is a variable (not an expression), it will be defined automatically before the function call.\n\nExample:\n\n```javascript\nsetTimeout(cont(), 1000);\n\nfs.lstat('/path/file', cont(err, stats));\n\nvar obj;\nfs.readdir('/path', cont(err, obj.files));\n```\n\nCompiled code:\n\n```javascript\nvar err, stats, obj;\nsetTimeout(function () {\n  fs.lstat('/path', function () {\n    err = arguments[0];\n    stats = arguments[1];\n    fs.readdir('/path', function () {\n      err = arguments[0];\n      obj.files = arguments[1];\n    });\n  });\n}, 1000);\n```\n\n### obtain\n\n``obtain`` is a syntax sugar of ``cont`` and ``throw``.\nYou can use ``try`` to catch asynchronous errors with ``obtain``.\nOne assumption is that the error object is the first parameter of the callback function (this is a convention of Node.js API).\n\nExample:\n\n```javascript\nfunction f1() {\n  fs.readdir('/path', obtain(files));\n}\n\nfunction f2() {\n  fs.readdir('/path', cont(err, files));\n  if (err)\n    throw err;\n}\n```\n\nCompiled code:\n\n```javascript\nfunction f1() {\n  var _$err, files;\n  fs.readdir('/path', function () {\n    _$err = arguments[0];\n    files = arguments[1];\n    if (_$err)\n      throw _$err;\n  });\n}\nfunction f2() {\n  var err, files;\n  fs.readdir('/path', function () {\n    err = arguments[0];\n    files = arguments[1];\n    if (err) {\n      throw err;\n    }\n  });\n}\n```\n\n### parallel\n\n``parallel`` allows you to execute asynchronous functions \"in parallel\".\n``parallel`` is also a virtual function and its parameters should be all function calls with ``cont`` or ``obtain``.\nAll function calls in ``parallel`` will be executed in parallel and control flow continues executing the next statement after all the parallel function calls \"return\" (precisely speaking callback functions called).\n\nNote that both Node.js and browser execute JavaScript code in single thread, so this is not a multithreaded implementation.\nThe function calls feel like entrances of threads so they can be called \"lightweight threads\".\nOnly I/O and computing are executed in parallel while computing are actually executed in sequence.\nThat is, when one \"thread\" is \"blocked\" by I/O, the other one runs.\nThe \"threads\" can automatically utilize the gaps of I/O and computing.\nSo you should let functions that both have I/O and computing run in parallel, rather than all functions with heavy computing and little I/O.\n\nExample:\n\n```javascript\nvar contents = {};\nparallel(\n  fs.readFile('/path1', obtain(contents.file1)),\n  fs.readFile('/path2', obtain(contents.file2)),\n  fs.readFile('/path3', obtain(contents.file3))\n);\nconsole.log(contents);\n```\n\n### Explicit mode\n\nModules can be written in Continuation.js and they will be recursively compiled automatically when using ``require``.\nAdd ``'use continuation'`` into your source file, and use ``continuation script.js --explicit`` to run it and only files contains ``'use continuation'`` will be compiled.\nThis option can reduce loading time if many modules are recursively required.\n\n### Compilation cache\n\nBy using ``contination script.js --cache [cacheDir]``, all modules compiled by Contination.js will be cached into ``cacheDir``.\nIf the timestamp of your source file is newer than the cached version, it will be compiled again.\nThis option rely on the system clock and it can also reduce loading time.\nIt is recommended to use ``--explicit`` and ``--cache`` together.\n\nBy default ``cacheDir`` is ``/tmp/continuation``.\n\n### Use Continuation.js in CoffeeScript (and other compile-to-js language)\n\nContinuation.js is compatible with most kinds of compile-to-js language because it introduces no non-primitive syntax.\nThe only 3 keywords ``cont``, ``obtain`` and ``parallel`` are all virtual functions so you can use function call directly in your language.\n\nExample (CoffeeScript):\n\n```coffeescript\ndns = require('dns')\ndomains = ['www.google.com', 'nodejs.org', 'www.byvoid.com']\nfor domain in domains\n  dns.resolve domain, obtain(addresses)\n  console.log addresses\n```\n\nUntil now [CoffeeScript](http://coffeescript.org/) and [LiveScript](http://livescript.net/) are supported by default.\n\n### Use Continuation.js programmatically\n\nYou are able to use Continuation.js programmatically.\nContinuation.js module has one interface function ``compile(code)``.\n``code`` must be a string.\n\nExample:\n\n```javascript\nvar continuation = require('continuation');\n\nfunction fibonacci() {\n  var a = 0, current = 1;\n  while (true) {\n    var b = a;\n    a = current;\n    current = a + b;\n    setTimeout(cont(), 1000);\n    console.log(current);\n  }\n};\n\nvar code = fibonacci.toString();\nvar compiledCode = continuation.compile(code);\nconsole.log(compiledCode);\neval(compiledCode);\nfibonacci();\n```\n\nYou can run the code above using ``node`` command.\nThat means you don't have to install Continuation.js in global environment.\nThe code above converts a function into a string, and then it is compiled by Continuation.js.\nAfter that you can run it via ``eval`` function.\n\n## Usage\n\n    Usage: continuation [options] <file.js/file.coffee/file.ls> [arguments]\n\n    Options:\n\n      -h, --help               output usage information\n      -V, --version            output the version number\n      -p, --print              compile script file and print it\n      -o, --output <filename>  compile script file and save as <filename>\n      -e, --explicit           compile only if \"use continuation\" is explicitly declared\n      -c, --cache [directory]  run and cache compiled sources to [directory], by default [directory] is /tmp/continuation\n      -v, --verbose            print verbosal information to stderr\n\nRun code written with Continuation.js (i.e. script.js):\n\n    contination script.js\n\nPrint compiled code on console:\n\n    contination script.js -p\n\nCompile code and save as another file:\n\n    contination script.js -o compiled.js\n\nRun code in \"explicit mode\" (only compile sources with ``'use continuation'``. see documentation):\n\n    contination script.js -e\n\nCache compiled code (including recursively required modules) to accelerate loading (see documentation):\n\n    contination script.js -c\n\n## Examples\n\n### Loops and sleep\n\nCalculating Fibonacci sequence and printing one number by every one second:\n\n```javascript\nvar fib = function () {\n  var a = 0, current = 1;\n  while (true) {\n    var b = a;\n    a = current;\n    current = a + b;\n    setTimeout(cont(), 1000);\n    console.log(current);\n  }\n};\nfib();\n```\n\n### Run asynchronous functions in sequence\n\nRead 5 files in sequence:\n\n```javascript\nvar fs = require('fs');\n\nfor (var i = 0; i < 4; i++) {\n  fs.readFile('text' + i + '.js', 'utf-8', obtain(text));\n  console.log(text);\n}\n\nconsole.log('Done');\n```\n\n### Run asynchronous functions in parallel\n\nDo things (with heave I/O) in parallel:\n\n```javascript\nvar fs = require('fs');\nvar dns = require('dns');\nvar http = require('http');\n\nvar complexWork = function (next) {\n  setTimeout(cont(), 500);\n  http.get('http://www.byvoid.com', cont(res));\n  next(null, res.headers);\n};\n\nparallel(\n  fs.readdir('/', obtain(files)),\n  dns.resolve('npmjs.org', obtain(addresses)),\n  complexWork(obtain(result))\n);\n\nconsole.log(files, addresses, result);\n```\n\n### Recursions\n\nCalculating disk usage:\n\n```javascript\nvar fs = require('fs');\n\nfunction calcDirSize(path, callback) {\n  var dirSize = 0, dirBlockSize = 0;\n  fs.readdir(path, obtain(files));\n  for (var i = 0; i < files.length; i++) {\n    var filename = path + '/' + files[i];\n    fs.lstat(filename, obtain(stats));\n    if (stats.isDirectory()) {\n      calcDirSize(filename, obtain(subDirSize, subDirBlockSize));\n      dirSize += subDirSize;\n      dirBlockSize += subDirBlockSize;\n    } else {\n      dirSize += stats.size;\n      dirBlockSize += 512 * stats.blocks;\n    }\n  }\n  callback(null, dirSize, dirBlockSize);\n}\n\nvar path = process.argv[2];\nif (!path) path = '.';\n\ncalcDirSize(path, obtain(totalSize, totalBlockSize));\n\nconsole.log('Size:', Math.round(totalSize / 1024), 'KB');\nconsole.log('Actual Size on Disk:', Math.round(totalBlockSize / 1024), 'KB');\n```\n\nMore examples are available in 'examples' directory and 'test' directory.\n\n## Relevant projects\n\nContinuation.js is not the only solution of CPS transformation, there are some alternatives.\nBelow is a comparison among projects related to synchronous to asynchronous transformation.\n\n<table>\n  <tr>\n    <th>Project</th>\n    <th>Continuation.js</th>\n    <th>streamline.js</th>\n    <th>TameJS</th>\n    <th>Wind.js</th>\n    <th>jwacs</th>\n    <th>NarrativeJS</th>\n    <th>StratifiedJS</th>\n  </tr>\n  <tr>\n    <td>Node.js support</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>No</td>\n    <td>No</td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Browser side support</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>No</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Additional runtime dependence</td>\n    <td>No</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>No</td>\n    <td>Yes</td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Additional syntax</td>\n    <td>No</td>\n    <td>No</td>\n    <td>Yes</td>\n    <td>No</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Compatibility with compile-to-js language</td>\n    <td>Yes</td>\n    <td>Yes (CoffeeScript)</td>\n    <td>Yes (CoffeeScript)</td>\n    <td>Yes (manually)</td>\n    <td>No</td>\n    <td>No</td>\n    <td>No</td>\n  </tr>\n  <tr>\n    <td>Parallel support</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Unknown</td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Readable generated code</td>\n    <td>Yes</td>\n    <td>No</td>\n    <td>Hardly</td>\n    <td>Almost</td>\n    <td>Unknown</td>\n    <td>No</td>\n    <td>Unknown</td>\n  </tr>\n  <tr>\n    <td>Asynchronous results passing syntax</td>\n    <td>Parameters</td>\n    <td>Return value</td>\n    <td>Parameters</td>\n    <td>Return value</td>\n    <td>Return value</td>\n    <td>Return value</td>\n    <td>Return value</td>\n  </tr>\n  <tr>\n    <td>Documentation</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>No</td>\n    <td>Yes</td>\n    <td>Yes</td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <td>Implemented in</td>\n    <td>JavaScript</td>\n    <td>JavaScript</td>\n    <td>JavaScript</td>\n    <td>JavaScript</td>\n    <td>Lisp</td>\n    <td>Java</td>\n    <td>JavaScript</td>\n  </tr>\n</table>\n\n## Contributers\n\n* [Carbo Kuo](https://github.com/BYVoid)\n* [curimit](https://github.com/curimit)\n* [Tomi Belan](https://github.com/TomiBelan)\n* [Reynir Björnsson](https://github.com/reynir)\n* [summivox](https://github.com/summivox)\n* [shankerwangmiao](https://github.com/shankerwangmiao)\n",
  "readmeFilename": "README.md",
  "_id": "continuation@0.1.7",
  "dist": {
    "shasum": "da028f91660d908fb690fbc80e266f724914de13"
  },
  "_from": "continuation@",
  "_resolved": "https://registry.npmjs.org/continuation/-/continuation-0.1.7.tgz"
}
